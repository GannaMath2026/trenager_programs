<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üç∫ –ü–¨–Ø–ù–ò–¶–´ - –ì–≠–ú–ë–õ! –ú–û–ë–ê–ô–õ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a3e 50%, #2d1b69 100%);
            min-height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden; touch-action: manipulation;
            -webkit-user-select: none; user-select: none;
        }
        
        /* üì± –ú–û–ë–ê–ô–õ –û–†–ò–ï–ù–¢–ê–¶–ò–Ø */
        @media (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "üîÑ –ü–û–í–ï–†–ù–ò–¢–ï –¢–ï–õ–ï–§–û–ù –í –ì–û–†–ò–ó–û–ù–¢–ê–õ–¨–ù–û–ï –ü–û–õ–û–ñ–ï–ù–ò–ï!";
                position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                background: rgba(0,0,0,0.95); color: #FFD700; font-size: 24px; 
                display: flex; align-items: center; justify-content: center; 
                z-index: 9999; font-weight: bold; text-align: center;
            }
        }
        
        .container { 
            max-width: 100vw; max-height: 100vh; 
            margin: 0; padding: 5px; 
            display: flex; flex-direction: column; height: 100vh; 
            gap: 10px;
        }
        
        /* üì± Canvas –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω */
        #canvas { 
            flex: 1; min-height: 0;
            border: 8px solid #ffd700; border-radius: 20px; 
            box-shadow: 0 20px 50px rgba(255,215,0,0.5); 
            width: 100%; height: auto; max-width: 100vw; max-height: 70vh;
            touch-action: none;
        }
        #canvas:hover { box-shadow: 0 25px 60px rgba(255,215,0,0.7); }
        
        /* üì± –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–Ω–∏–∑—É */
        .panel { 
            flex-shrink: 0;
            background: linear-gradient(145deg, rgba(255,255,255,0.98), rgba(240,240,255,0.95)); 
            border-radius: 20px; padding: 15px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); 
            border: 2px solid #ffd700;
            font-size: 14px;
        }
        
        /* üì± –ö–Ω–æ–ø–∫–∏ –∫—Ä—É–ø–Ω–µ–µ –¥–ª—è –ø–∞–ª—å—Ü–µ–≤ */
        input[type=number], input[type=range] { 
            width: 100%; padding: 12px; border-radius: 10px; 
            background: linear-gradient(to right, #e0e0ff, #f0f0ff); 
            border: 2px solid #aaa; outline: none; margin: 6px 0; 
            font-size: 16px; /* prevents zoom */
        }
        
        button { 
            width: 100%; padding: 18px; margin: 6px 0; border: none; 
            border-radius: 20px; font-size: 20px; font-weight: bold; 
            cursor: pointer; background: linear-gradient(45deg, #ff6b6b, #ff8e8e); 
            color: white; transition: all 0.3s; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            min-height: 50px; /* –¥–ª—è –ø–∞–ª—å—Ü–µ–≤ */
        }
        button:hover:not(:disabled), button:active:not(:disabled) { 
            transform: translateY(-2px) scale(1.02); 
            box-shadow: 0 15px 40px rgba(255,100,0,0.8); 
        }
        button:disabled { background: linear-gradient(45deg, #666, #888); cursor: not-allowed; }
        
        #simulations { 
            font-size: 22px; font-weight: bold; text-align: center; 
            margin: 10px 0; padding: 15px; border-radius: 15px; 
            background: linear-gradient(135deg, rgba(78,205,196,0.3), rgba(255,215,0,0.3)); 
            border: 2px dashed #ffd700; 
        }
        
        .stats { 
            font-size: 15px; margin-top: 10px; padding: 15px; 
            background: rgba(255,255,255,0.9); border-radius: 12px; 
            display: flex; justify-content: space-around; 
        }
        .stat-item { text-align: center; }
        .stat-value { font-size: 22px; font-weight: bold; display: block; color: #ff6b6b; }
        
        h2 { font-size: 18px; margin-bottom: 8px; }
        label { font-size: 14px; font-weight: bold; display: block; margin: 4px 0; }
        
        /* üñ•Ô∏è –î–ï–°–ö–¢–û–ü –≤–µ—Ä—Å–∏—è */
        @media (min-width: 769px) {
            .container { 
                flex-direction: row; 
                max-width: 1600px; margin: 0 auto; padding: 10px; 
                grid-template-columns: 1fr 350px; gap: 20px;
            }
            #canvas { 
                width: 1400px; height: 800px;
                border: 10px solid #ffd700; border-radius: 25px;
            }
            .panel { padding: 20px; font-size: 15px; }
            button { padding: 15px; font-size: 18px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas" width="1400" height="800"></canvas>
        <div class="panel">
            <h2>üç∫ –ì–≠–ú–ë–õ! –¢–û–õ–ü–ê –ü–¨–Ø–ù–ò–¶</h2>
            <label>üë• –ü—å—è–Ω–∏—Ü:</label>
            <input type="number" id="simCountInput" min="20" max="300" value="100">
            <label>P(–∫ –æ–±—Ä—ã–≤—É):</label>
            <span id="pValue" style="color:#ff6b6b; font-weight: bold; font-size: 18px;">0.20</span>
            <input type="range" id="pCliff" min="0.1" max="0.9" step="0.05" value="0.2">
            <label>‚ö° –°–∫–æ—Ä–æ—Å—Ç—å:</label>
            <span id="speedValue" style="color:#4ecdc4; font-weight: bold; font-size: 18px;">1.0x</span>
            <input type="range" id="speedSlider" min="0.3" max="4.0" step="0.1" value="1.0">
            
            <button id="startBtn" onclick="startSimulation()" disabled="">üöÄ –¢–û–õ–ü–ê –ù–ê –°–¢–ê–†–¢!</button>
            <button id="nextBtn" onclick="launchNext()">‚û°Ô∏è –°–õ–ï–î–£–Æ–©–ò–ô –ü–û–®–ï–õ!</button>
            <button onclick="launchAll()">‚ö° –í–°–ï–ô –¢–û–õ–ü–û–ô –í–ü–ï–†–ï–î!!</button>
            <button onclick="resetAll()">üîÑ –ü–ï–†–ï–ó–ê–ì–†–£–ó–ö–ê</button>
            
            <div id="simulations">üíÄ0 | üëº0</div>
            <div class="stats">
                <div class="stat-item">
                    <span>P(–ø–∞–¥–µ–Ω–∏—è)</span>
                    <span id="theory" class="stat-value">0.250</span>
                </div>
                <div class="stat-item">
                    <span>–û–∂–∏–¥–∞–µ—Ç—Å—è</span>
                    <span id="expectation" class="stat-value">25</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // üì± –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä canvas
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width - 16;  // –º–∏–Ω—É—Å border
            canvas.height = rect.height - 16;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        let pCliff = 0.2, speed = 1.0, drunkards = [], activeQueue = [], particles = [], speechBubbles = [], clouds = [];
        let topText = '', pitCount = 0, cloudCount = 0;
        
        // üéµ –ó–≤—É–∫–∏ (—Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ –º–æ–±–∞–π–ª)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playFallSound() {
            try {
                const osc = audioContext.createOscillator(), gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(200, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                osc.type = 'sawtooth'; osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime + 0.4);
            } catch(e) {}
        }
        function playHeavenSound() {
            try {
                const osc = audioContext.createOscillator(), gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(800, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                osc.type = 'sine'; osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime + 0.3);
            } catch(e) {}
        }
        function playDrunkStep() {
            try {
                const osc = audioContext.createOscillator(), gain = audioContext.createGain();
                osc.connect(gain); gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(150 + Math.random()*50, audioContext.currentTime);
                gain.gain.setValueAtTime(0.08, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                osc.type = 'square'; osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime + 0.08);
            } catch(e) {}
        }
        
        // –û–±–ª–∞–∫–∞
        function initClouds() {
            clouds = [];
            for(let i = 0; i < 6; i++) {
                clouds.push({x: Math.random()*canvas.width, y: Math.random()*80+80, speed: 0.4+Math.random()*0.3, size: 20+Math.random()*25});
            }
        }
        initClouds();

        function calculateProbability(p) {
            if (p >= 0.5) return "1.000";
            return (p / (1-p)).toFixed(3);
        }
        function calculateExpectation(count, p) {
            const prob = p >= 0.5 ? 1 : p / (1-p);
            return Math.round(count * prob);
        }

        function updateUI() {
            document.getElementById('pValue').textContent = pCliff.toFixed(2);
            document.getElementById('speedValue').textContent = speed.toFixed(1) + 'x';
            document.getElementById('theory').textContent = calculateProbability(pCliff);
            document.getElementById('expectation').textContent = calculateExpectation(drunkards.length || 100, pCliff);
            document.getElementById('simulations').innerHTML = `üíÄ${pitCount} | üëº${cloudCount}`;
            
            const count = drunkards.length || 100;
            if (pCliff >= 0.5) {
                topText = `P(–ø–∞–¥–µ–Ω–∏—è) = 1.000`;
            } else {
                topText = `P(–ø–∞–¥–µ–Ω–∏—è) = ${pCliff.toFixed(1)}/${(1-pCliff).toFixed(1)} = ${calculateProbability(pCliff)}`;
            }
        }

        document.getElementById('pCliff').oninput = e => {
            pCliff = +e.target.value;
            updateUI();
        };
        document.getElementById('speedSlider').oninput = e => {
            speed = +e.target.value;
            updateUI();
        };
        document.getElementById('simCountInput').oninput = updateUI;

        function drawRoad() {
            const roadY = canvas.height*0.55;
            
            ctx.fillStyle = '#1a0f0a'; 
            ctx.fillRect(0, roadY-15, canvas.width*0.18, canvas.height - (roadY-15));
            
            ctx.fillStyle = '#8B4513'; 
            ctx.fillRect(canvas.width*0.18, roadY, canvas.width*0.82 + 50 - canvas.width*0.18, 30);
            ctx.fillStyle = '#D2691E'; 
            ctx.fillRect(canvas.width*0.18, roadY, canvas.width*0.82 + 50 - canvas.width*0.18, 15);
            
            ctx.fillStyle = '#FFD700';
            for(let i = 0; i < 32; i++) {
                ctx.fillRect(canvas.width*0.18 + i*28, roadY+4, 20, 5);
            }
            
            const rightGradient = ctx.createLinearGradient(canvas.width*0.75, 0, canvas.width, 0);
            rightGradient.addColorStop(0, '#F0E68C');
            rightGradient.addColorStop(1, '#4a3d2a');
            ctx.fillStyle = rightGradient;
            ctx.fillRect(canvas.width*0.75, 0, canvas.width*0.25, canvas.height);
            
            // –î–≤–µ—Ä—å —Ä–∞—è
            ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 20;
            const doorX = canvas.width*0.82, doorY = roadY - 20;
            ctx.fillRect(doorX, doorY, 50, 50);
            ctx.fillStyle = '#FFF8DC'; 
            ctx.fillRect(doorX+6, doorY+6, 38, 38);
            ctx.shadowBlur = 0;
            
            const gradient = ctx.createRadialGradient(doorX+25, doorY+25, 0, doorX+25, doorY+25, 60);
            gradient.addColorStop(0, 'rgba(255,255,200,0.7)');
            gradient.addColorStop(1, 'rgba(255,215,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(doorX-15, doorY-15, 80, 80);
            
            ctx.shadowColor = '#ff1111'; ctx.shadowBlur = 25;
            ctx.fillStyle = '#ff1111'; ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center';
            ctx.fillText('üî• –ê–î', canvas.width*0.09, canvas.height*0.45);
            ctx.shadowBlur = 0;
            
            ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 30;
            ctx.fillStyle = '#ff6600'; ctx.font = 'bold 36px Arial'; 
            ctx.fillText('üëº –†–ê–ô', doorX+25, doorY-12);
            ctx.shadowBlur = 0;
        }

        function updateClouds() {
            clouds.forEach(cloud => { 
                cloud.x += cloud.speed * speed * 0.4; 
                if (cloud.x > canvas.width+80) cloud.x = -80; 
            });
        }

        function drawPuppet(x, y, id, state) {
            ctx.save(); ctx.translate(x, y);
            const sway = Math.sin(Date.now()*0.01* speed +id)*1.5;
            const walk = Math.sin(Date.now()*0.03* speed +id)*8;
            ctx.rotate(sway*0.1); ctx.translate(0, walk*0.15);
            
            const nearHell = state.position < 5 && !state.fallen && !state.saved;
            if (nearHell) {
                ctx.fillStyle = '#8B0000';
                ctx.beginPath(); ctx.moveTo(-8,-40); ctx.lineTo(-14,-52); ctx.lineTo(-4,-48); ctx.fill();
                ctx.beginPath(); ctx.moveTo(8,-40); ctx.lineTo(14,-52); ctx.lineTo(4,-48); ctx.fill();
            }
            
            // üëº –ù–ò–ú–ë: –ó–ê 3 –°–ï–ì–ú–ï–ù–¢–ê –î–û –î–í–ï–†–ò (position >= 29)
            if (state.position >= 29 && !state.fallen) {
                const haloPulse = Math.sin(Date.now()*0.02 + id) * 0.3 + 1;
                ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 25;
                ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 5 * haloPulse;
                ctx.beginPath();
                ctx.arc(0, -40, 18, 0, Math.PI*2);
                ctx.stroke();
                ctx.lineWidth = 2.5 * haloPulse;
                ctx.strokeStyle = '#FFF8DC';
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            ctx.fillStyle = state.fallen ? '#8B0000' : (state.saved ? '#FFD700' : `hsl(${120+id*5}, 70%, 55%)`);
            ctx.fillRect(-10, -20, 20, 28);
            
            ctx.strokeStyle = state.fallen ? '#500' : (state.saved ? '#fff' : '#2c3e50');
            ctx.lineWidth = 6; ctx.lineCap = 'round';
            const legSwing = Math.sin(Date.now()*0.04* speed +id)*12;
            ctx.beginPath(); ctx.moveTo(-5,1); ctx.lineTo(-16,18+legSwing); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(5,1); ctx.lineTo(16,18-legSwing); ctx.stroke();
            
            ctx.beginPath(); ctx.arc(0, -32, 12, 0, Math.PI*2);
            ctx.fillStyle = state.fallen ? '#654321' : (state.saved ? '#FFE4B5' : '#f4a261');
            ctx.fill();
            
            if (state.fallen) {
                ctx.fillStyle = '#8B0000';
                ctx.beginPath(); ctx.moveTo(-8,-40); ctx.lineTo(-14,-52); ctx.lineTo(-4,-48); ctx.fill();
                ctx.beginPath(); ctx.moveTo(8,-40); ctx.lineTo(14,-52); ctx.lineTo(4,-48); ctx.fill();
            }
            
            ctx.fillStyle = state.fallen ? '#FF4500' : (state.saved ? '#00ff88' : '#e74c3c');
            ctx.beginPath(); ctx.arc(-6,-33,3.5,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(6,-32,3.5,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }

        function createSpeechBubble(x, y, text, color = '#ffeb3b') {
            speechBubbles.push({x, y, text, color, life: 1, decay: 0.012/speed, vx: (Math.random()-0.5)*1.5, vy: -Math.random()*4-1.5});
        }

        const fallPhrases = ['–û–π!', '–ê–∞–∞!', '–í —è–º—É!', 'üò±', '–ë—É!', '–ù–µ–µ—Ç!'];
        const heavenPhrases = ['–£—Ä–∞!', '–†–∞–π!', 'üëº', '–ô–µ–µ!', '–°–≤–µ—Ç!', '–ü—Ä–æ—à–µ–ª!'];

        function createParticles(x, y, count, color) {
            for(let i = 0; i < count; i++) {
                particles.push({x, y, vx: (Math.random()-0.5)*15, vy: -Math.random()*12, life: 1, decay: 0.035*speed, size: 2.5+Math.random()*2.5, color});
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx * speed * 0.12; p.y += p.vy * speed * 0.12; p.vy += 0.2;
                p.life -= p.decay; p.size *= 0.96;
                return p.life > 0;
            });
            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            });
        }

        function updateSpeechBubbles() {
            speechBubbles = speechBubbles.filter(b => {
                b.x += b.vx * speed * 0.12; b.y += b.vy * speed * 0.12; b.vy += 0.08;
                b.life -= b.decay;
                return b.life > 0;
            });
            speechBubbles.forEach(b => {
                ctx.save(); ctx.globalAlpha = b.life;
                ctx.fillStyle = b.color; ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
                const w = ctx.measureText(b.text).width + 16;
                ctx.beginPath(); 
                ctx.roundRect(b.x-w/2, b.y-18, w, 28, 8); 
                ctx.fill(); ctx.stroke();
                ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(b.text, b.x, b.y); ctx.restore();
            });
        }

        function drawCounters() {
            ctx.fillStyle = '#ff1111'; ctx.shadowColor = '#ff1111'; ctx.shadowBlur = 20;
            ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`üíÄ ${pitCount}`, canvas.width*0.08, canvas.height*0.75);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#FFD700'; ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 25;
            ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`üëº ${cloudCount}`, canvas.width*0.92, canvas.height*0.15);
            ctx.shadowBlur = 0;
        }

        function draw() {
            const gradient = ctx.createLinearGradient(0,0,0,canvas.height);
            gradient.addColorStop(0,'#87CEEB'); gradient.addColorStop(0.6,'#F0E68C'); gradient.addColorStop(1,'#8B4513');
            ctx.fillStyle = gradient; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.fillRect(10, 3, canvas.width-20, 70);
            
            ctx.fillStyle = '#FFD700'; 
            ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 20;
            ctx.font = 'bold 28px Arial'; ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(topText, 20, 38);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#FF6B6B'; 
            ctx.shadowColor = '#FF6B6B'; ctx.shadowBlur = 12;
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`E[–ø–∞–¥—à–∏—Ö] = ${calculateExpectation(drunkards.length || 100, pCliff)}`, 20, 65);
            ctx.shadowBlur = 0;
            
            updateClouds();
            ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 20;
            clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI*2);
                ctx.arc(cloud.x+cloud.size*0.6, cloud.y-8, cloud.size*0.8, 0, Math.PI*2);
                ctx.arc(cloud.x-cloud.size*0.6, cloud.y+4, cloud.size*0.7, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
            
            drawRoad(); updateParticles(); updateSpeechBubbles(); drawCounters();
            
            ctx.globalAlpha = 0.6;
            drunkards.forEach((d,i) => {
                if (!d.launched) {
                    const startX = canvas.width * 0.18 + 28;
                    const row = Math.floor(i/20), col = i%20;
                    drawPuppet(startX+(col-10)*18, canvas.height*0.55+row*22, i, d);
                }
            });
            ctx.globalAlpha = 1;
            
            activeQueue.forEach((d,i) => {
                const roadX = canvas.width*0.18 + d.position * 28;
                drawPuppet(roadX, canvas.height*0.55, drunkards.indexOf(d), d);
            });
        }

        function startSimulation() {
            const count = Math.max(20, Math.min(300, +document.getElementById('simCountInput').value || 100));
            document.getElementById('simCountInput').value = count;
            
            drunkards = Array(count).fill().map((_,i) => ({
                position: 1, fallen: false, saved: false, launched: false
            }));
            activeQueue = []; particles = []; speechBubbles = []; pitCount = 0; cloudCount = 0;
            initClouds();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('simulations').textContent = `${count} –ø—å—è–Ω–∏—Ü –≥–æ—Ç–æ–≤–æ!`;
            updateUI();
        }

        function launchNext() {
            const remaining = drunkards.filter(d=>!d.launched).length;
            const toLaunch = Math.min(6, remaining);
            
            for(let i = 0; i < toLaunch; i++) {
                const d = drunkards.find(d=>!d.launched);
                if (d) { 
                    d.launched = true; 
                    activeQueue.push(d); 
                    createSpeechBubble(canvas.width*0.18 + 28, canvas.height*0.52, '–ò–¥—É!');
                    playDrunkStep();
                }
            }
            
            activeQueue = activeQueue.filter(d => {
                if (!d.fallen && !d.saved) {
                    d.position += Math.random() < pCliff ? -1 : 1;
                    playDrunkStep();
                    if (d.position <= 0) {
                        d.fallen = true; pitCount++;
                        createParticles(canvas.width*0.15, canvas.height*0.57, 12, '#ff1111');
                        createSpeechBubble(canvas.width*0.15, canvas.height*0.55, fallPhrases[Math.floor(Math.random()*fallPhrases.length)], '#ff1111');
                        playFallSound();
                    } else if (d.position >= 32) {
                        d.saved = true; cloudCount++;
                        createParticles(canvas.width*0.85, canvas.height*0.52, 16, '#FFD700');
                        createSpeechBubble(canvas.width*0.85, canvas.height*0.48, heavenPhrases[Math.floor(Math.random()*heavenPhrases.length)], '#FFD700');
                        playHeavenSound();
                    }
                    return true;
                }
                return false;
            });
            updateUI();
            draw();
        }

        function launchAll() {
            drunkards.forEach(d => { if (!d.launched) { d.launched = true; activeQueue.push(d); } });
            document.getElementById('nextBtn').disabled = true;
            document.getElementById('simulations').textContent = '‚ö° –í–°–ï–ô –¢–û–õ–ü–û–ô –ë–ï–ñ–ò–¢!!';
            
            let step = 0;
            const sim = setInterval(() => {
                step++;
                activeQueue = activeQueue.filter(d => {
                    if (!d.fallen && !d.saved) {
                        d.position += Math.random() < pCliff ? -1 : 1;
                        playDrunkStep();
                        if (d.position <= 0) { 
                            d.fallen = true; pitCount++; 
                            playFallSound(); 
                        }
                        else if (d.position >= 32) { 
                            d.saved = true; cloudCount++; 
                            playHeavenSound(); 
                        }
                        return true;
                    }
                    return false;
                });
                updateUI();
                draw();
                if (activeQueue.length === 0 && drunkards.filter(d=>!d.fallen && !d.saved).length === 0) {
                    clearInterval(sim);
                }
            }, 60 / speed);
        }

        function resetAll() {
            drunkards = []; activeQueue = []; particles = []; speechBubbles = []; pitCount = 0; cloudCount = 0;
            initClouds();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('nextBtn').disabled = true;
            document.getElementById('simulations').textContent = 'üéä –ü–ï–†–ï–ó–ê–ì–†–£–ó–ö–ê –ì–û–¢–û–í–ê!';
            updateUI();
            draw();
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        updateUI();
        animate();
    </script>
</body>
</html>
