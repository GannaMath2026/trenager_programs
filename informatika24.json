[
  {
    "name": "2250к",
    "codeWithComments": "\n# f=open(r'D:\\24-2250.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='AAATBQBNRXGZVPUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQLBFDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdjgldjdlfg'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl=0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ss.count('A') > 1:\n        # проверяем: если в подстроке БОЛЬШЕ одной буквы 'A' (т.е. 2 и более)\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # так как добавление новых символов не уберёт лишние буквы 'A'\n        if ss.count('A') <= 1:\n        # если в подстроке 0 или 1 буква 'A' - это допустимая подстрока\n            dl = len(ss)\n            # обновляем максимальную длину dl\n            # текущая подстрока длиннее всех предыдущих\n            print(f'i={i}, dl={dl}, строка:{ss}')\n            # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "",
    "answer": "53",
    "image": "",
    "text": "Текстовый файл содержит только заглавные буквы латинского алфавита(ABC…Z). \r\nОпределите максимальное количество идущих подряд символов, среди которых не более одной буквы A.\r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "2426к",
    "codeWithComments": "# f=open(r'D:\\24-2426.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='1213231323ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123AB132313231231233C123ABC123ABC123ABC123ABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'A' in ss or 'B' in ss or 'C' in ss:\n        # если в подстроке есть буква\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # если в подстроке нет букв - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим найденную подстроку и её длину (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока без букв будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-2426.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='1213231323ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123AB132313231231233C123ABC123ABC123ABC123ABC'\n# создаём тестовую строку из символов 1,2,3,A,B,C вручную, так # как в этой среде нет доступа к файлу\n\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if 'A' in ss or 'B' in ss or 'C' in ss:\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "15",
    "image": "",
    "text": "Текстовый файл состоит не более чем из 106 символов 1, 2, 3, A, B, C.\r\nОпределите максимальное количество идущих подряд цифр\r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "1428к",
    "codeWithComments": "# f=open(r'D:\\24-1428.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='AAATBQBXYNRXGZVPXZUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJXZXZXZJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQXZLBFXYDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdXZjgldjdlfg'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl=0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'XY' in ss or 'XZ' in ss:\n        # если в подстроке есть 'XY' или 'XZ'\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        # если в подстроке нет ни 'XY', ни 'XZ' - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-1428.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='AAATBQBXYNRXGZVPXZUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJXZXZXZJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQXZLBFXYDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdXZjgldjdlfg'\n\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if 'XY' in ss or 'XZ' in ss:\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "85",
    "image": "",
    "text": "Текстовый файл состоит не более чем из 106 символов 1, 2, 3, A, B, C.\r\nОпределите максимальное количество идущих подряд цифр\r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "7223к",
    "codeWithComments": "# f=open(r'D:\\24-xxx.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='ABCDABEDFGABCHIJKABCLMNOPQRSABCTUVWXYZABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if len(set(ss)) < len(ss):\n        # проверяем: если количество уникальных символов меньше длины подстроки\n        # значит есть повторяющиеся буквы\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # так как добавление новых символов не уберёт повторы\n        # если все символы уникальны (нет повторяющихся букв)\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока без повторяющихся букв будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-xxx.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\n\ns='ABCDABEDFGABCHIJKABCLMNOPQRSABCTUVWXYZABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\n\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if len(set(ss)) < len(ss):\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "18",
    "image": "",
    "text": "Определите длину самой длинной подпоследовательности символов, в которой нет повторяющихся букв",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "9753п",
    "codeWithComments": "# f=open(r'D:\\24-9753.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='TUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY'\n# создаём тестовую строку из символов T,U,V,W,X,Y,Z вручную\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ss.count('Y') > 150:\n        # если в подстроке больше 150 букв Y\n            break\n            # прерываем внутренний цикл - дальше расширять нельзя\n        # если Y не больше 150 - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}')\n        # выводим информацию о найденной подстроке\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-9753.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='TUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZTUVWXYZYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if ss.count('Y') > 150:\n            break\n        dl = len(ss)\n        print(i, dl)\n        j += 1",
    "answer": "244",
    "image": "",
    "text": "Текстовый файл состоит из символов T, U, V, W, X, Y и Z.\r\nОпределите в прилагаемом файле максимальное количество идущих подряд символов (длину непрерывной подпоследовательности), среди которых символ Y встречается не более 150 раз.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "12476п",
    "codeWithComments": "# f=open(r'D:\\24-12476.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='ROROROROROROROROROROROROROROROROROROROROROROROROROROROROOROROROROROROROROROROROROROROROROROROROROROROROROROROR'\n# создаём тестовую строку вручную\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ss.count('RO') > 21 or 'ORO' in ss or 'ROR' in ss:\n        # если RO больше 21 или есть ORO или ROR\n            break\n            # прерываем внутренний цикл\n        # если условия соблюдены - допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-12476.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='ROROROROROROROROROROROROROROROROROROROROROROROROROROROROOROROROROROROROROROROROROROROROROROROROROROROROROROROR'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if ss.count('RO') > 21 or 'ORO' in ss or 'ROR' in ss:\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "814",
    "image": "",
    "text": "Определите в прилагаемом файле максимальное количество идущих подряд символов, среди которых комбинация символов RO встречается ровно 21 раз, а комбинации символов ORO и ROR ни разу не встречаются.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "2715п",
    "codeWithComments": "# f=open(r'D:\\24-2715.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='1234567890123456789012345678901234567890123456789012345678901234567890'\n# создаём тестовую строку вручную\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if not (all(int(c)%2==0 for c in ss) or all(int(c)%2==1 for c in ss)):\n        # если не все цифры чётные и не все нечётные\n            break\n            # прерываем внутренний цикл\n        # если все цифры одинаковой чётности - допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-2715.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='1234567890123456789012345678901234567890123456789012345678901234567890'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if not (all(int(c)%2==0 for c in ss) or all(int(c)%2==1 for c in ss)):\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "18",
    "image": "",
    "text": "Найдите максимальную длину последовательности, которая состоит из цифр одинаковой четности.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "7203п",
    "codeWithComments": "# f=open(r'D:\\24-7203.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='USNNSUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNXYXUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSN'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'X' in ss or 'Y' in ss:\n        # проверяем: если в подстроке есть X или Y (запрещённые буквы)\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        if ss.count('S') > 10 or ss.count('U') > 10 or ss.count('N') > 10:\n        # проверяем: если какая-то из букв S, U, N встречается больше 10 раз\n            break\n            # прерываем внутренний цикл - превышен лимит\n        # если все условия соблюдены - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-7203.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='USNNSUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNXYXUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSN'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if 'X' in ss or 'Y' in ss:\n            break\n        if ss.count('S') > 10 or ss.count('U') > 10 or ss.count('N') > 10:\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "30",
    "image": "",
    "text": "Определите максимальное количество идущих подряд символов, среди которых каждая из букв S, U и N \r\nвстречается не более 10 раз, а буквы X и Y не встречаются совсем. \r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
{
    "name": "5152п",
    "codeWithComments": "# f=open(r'D:\\24-5152.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC'\n# создаём тестовую строку вручную\n#=============================================================\nk = 0\n# переменная для подсчёта количества подходящих подстрок\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок\n    j = i + 3\n    # начинаем с минимальной длины 3\n    while j <= len(s):\n    # пока индекс конца не вышел за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку\n        if ('A' in ss) + ('B' in ss) + ('C' in ss) < 3:\n        # если не все три буквы A,B,C присутствуют одновременно\n            k += 1\n            # увеличиваем счётчик\n            print(i, k, ss)\n            # выводим информацию\n            j += 1\n            # пробуем расширить подстроку\n        else:\n        # если все три буквы есть\n            break\n            # прерываем цикл\n#=============================================================\n# после завершения всех циклов в переменной k хранится искомое количество",
    "codeNoComments": "# f=open(r'D:\\24-5152.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='ABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC'\n#=============================================================\nk = 0\nfor i in range(len(s)):\n    j = i + 3\n    while j <= len(s):\n        ss = s[i:j]\n        if ('A' in ss) + ('B' in ss) + ('C' in ss) < 3:\n            k += 1\n            print(i, k, ss)\n            j += 1\n        else:\n            break",
    "answer": "252776",
    "image": "",
    "text": "Определите количество подстрок длиной не менее трех символов, которые не содержали бы одновременно все три буквы A, B и C.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  }
]