[
  {
    "name": "2250к",
    "codeWithComments": "\n# f=open(r'D:\\24-2250.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='AAATBQBNRXGZVPUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQLBFDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdjgldjdlfg'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl=0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ss.count('A') > 1:\n        # проверяем: если в подстроке БОЛЬШЕ одной буквы 'A' (т.е. 2 и более)\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # так как добавление новых символов не уберёт лишние буквы 'A'\n        if ss.count('A') <= 1:\n        # если в подстроке 0 или 1 буква 'A' - это допустимая подстрока\n            dl = len(ss)\n            # обновляем максимальную длину dl\n            # текущая подстрока длиннее всех предыдущих\n            print(f'i={i}, dl={dl}, строка:{ss}')\n            # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-2250.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='AAATBQBNRXGZVPUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQLBFDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdjgldjdlfg'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if ss.count('A') > 1:\n            break\n        if ss.count('A') <= 1:\n            dl = len(ss)\n            print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "53",
    "image": "",
    "text": "Текстовый файл содержит только заглавные буквы латинского алфавита(ABC…Z). \r\nОпределите максимальное количество идущих подряд символов, среди которых не более одной буквы A.\r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "2426к",
    "codeWithComments": "# f=open(r'D:\\24-xxx.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='123ABC123ABC123ABC1213213213223ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC12312312311321321321321ABC123ABC'\n# создаём тестовую строку из символов 1,2,3,A,B,C\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки из цифр (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'A' in ss or 'B' in ss or 'C' in ss:\n        # проверяем: если в подстроке есть хотя бы одна буква (A, B или C)\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # так как добавление новых символов не уберёт буквы\n        # если в подстроке только цифры (1,2,3) - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока из цифр будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-xxx.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='123ABC123ABC123ABC1213213213223ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC12312312311321321321321ABC123ABC'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if 'A' in ss or 'B' in ss or 'C' in ss:\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "23",
    "image": "",
    "text": "Текстовый файл состоит не более чем из 10^6 символов 1, 2, 3, A, B, C.\r\nОпределите максимальное количество идущих подряд цифр\r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": true
  },
  {
    "name": "1428к",
    "codeWithComments": "# f=open(r'D:\\24-1428.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='AAATBQBXYNRXGZVPXZUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJXZXZXZJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQXZLBFXYDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdXZjgldjdlfg'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl=0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'XY' in ss or 'XZ' in ss:\n        # если в подстроке есть 'XY' или 'XZ'\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        # если в подстроке нет ни 'XY', ни 'XZ' - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-1428.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='AAATBQBXYNRXGZVPXZUNZFAHNGIOEVLIDMJVNDLLRAAKMMVXYHFQNWAANJXZXZXZJGCTEXCIQUPAIDFDIGLODASCPTXPCJCQKYEEANGFCYIXWFJFMAAAJDELCFAQVBHWUJTBXEFJKTZHAAAATGQXZLBFXYDBFRWRAKJBCZIBULBICJCJJYHXUWAFAUVIYYYLLLKDXCQWKLjglkldgdgjdkgjdlkgjdlfjgdXZjgldjdlfg'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if 'XY' in ss or 'XZ' in ss:\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "85",
    "image": "",
    "text": "Текстовый файл состоит не более чем из 10^6 символов 1, 2, 3, A, B, C. Определите максимальное количество идущих подряд цифр",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "7223к",
    "codeWithComments": "# f=open(r'D:\\24-xxx.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='ABCDABEDFGABCHIJKABCLMNOPQRSABCTUVWXYZABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if len(set(ss)) < len(ss):\n        # проверяем: если количество уникальных символов меньше длины подстроки\n        # значит есть повторяющиеся буквы\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n            # так как добавление новых символов не уберёт повторы\n        # если все символы уникальны (нет повторяющихся букв)\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока без повторяющихся букв будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-xxx.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\n\ns='ABCDABEDFGABCHIJKABCLMNOPQRSABCTUVWXYZABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\n\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if len(set(ss)) < len(ss):\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "18",
    "image": "",
    "text": "Определите длину самой длинной подпоследовательности символов, в которой нет повторяющихся букв",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "9753п",
    "codeWithComments": "# f=open(r'D:\\24-9753.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='T'+'Y'*150+'ASDA'+'YS'*152+'QWEQ'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ss.count('Y') > 150:\n        # если в подстроке больше 150 букв Y\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        # если Y не больше 150 - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss[:20]}...')\n        # выводим информацию о найденной подстроке (первые 20 символов для краткости)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-9753.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='T'+'Y'*150+'ASDA'+'YS'*152+'QWEQ'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if ss.count('Y') > 150:\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss[:20]}...')\n        j += 1",
    "answer": "305",
    "image": "",
    "text": "Текстовый файл состоит из символов T, U, V, W, X, Y и Z.\r\nОпределите в прилагаемом файле максимальное количество идущих подряд символов (длину непрерывной подпоследовательности), среди которых символ Y встречается не более 150 раз.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "12476п",
    "codeWithComments": "# f=open(r'D:\\24-12476.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='REGERRRGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGEROGROPROROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHRRGPPOPREOEROEPEEGPGRERRPOPRGRRRPPPOEGORREOOEGOEEGREGGORREOGGEOOEPPGOORROPPEPROGPORGEGEEOEGERRPEOPRGGEEGOOORPEEEOGEEOGRROROOPEORREGRRGRPOEPERROOR'\n# создаём тестовую строку вручную\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'ORO' in ss or 'ROR' in ss:\n        # если в подстроке есть ORO или ROR - запрещённые комбинации\n            break\n            # прерываем внутренний цикл\n        if ss.count('RO') > 21:\n        # если RO больше 21 - превышен лимит\n            break\n            # прерываем внутренний цикл\n        if ss.count('RO') == 21:\n        # если RO ровно 21 раз - это искомая подстрока\n            dl = len(ss)\n            # обновляем максимальную длину dl\n            print(f'i={i}, dl={dl}, строка:{ss}')\n            # выводим информацию о найденной подстроке\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-12476.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='REGERRRGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGROGEROGROPROROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHROHRRGPPOPREOEROEPEEGPGRERRPOPRGRRRPPPOEGORREOOEGOEEGREGGORREOGGEOOEPPGOORROPPEPROGPORGEGEEOEGERRPEOPRGGEEGOOORPEEEOGEEOGRROROOPEORREGRRGRPOEPERROOR'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if ss.count('RO') > 21 or 'ORO' in ss or 'ROR' in ss:\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "814",
    "image": "",
    "text": "Определите в прилагаемом файле максимальное количество идущих подряд символов, среди которых комбинация символов RO встречается ровно 21 раз, а комбинации символов ORO и ROR ни разу не встречаются.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "2715п",
    "codeWithComments": "# f=open(r'D:\\24-2715.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='123446464848405678901213575799575573456789012345678901234567890123456789012345678901234567824266800224426666600290'\n# создаём тестовую строку вручную\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if not (all(int(c)%2==0 for c in ss) or all(int(c)%2==1 for c in ss)):\n        # если не все цифры чётные или не все нечётные\n            break\n            # прерываем внутренний цикл\n        # если все цифры одинаковой чётности - допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина",
    "codeNoComments": "# f=open(r'D:\\24-2715.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='123446464848405678901213575799575573456789012345678901234567890123456789012345678901234567824266800224426666600290'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if not (all(int(c)%2==0 for c in ss) or all(int(c)%2==1 for c in ss)):\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "22",
    "image": "",
    "text": "Найдите максимальную длину последовательности, которая состоит из цифр одинаковой четности.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "7203п",
    "codeWithComments": "# f=open(r'D:\\24-7203.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='USNNSUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNXYXUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSN'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения максимальной длины найденной подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущий максимум на dl (оптимизация)\n    while i <= j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if 'X' in ss or 'Y' in ss:\n        # проверяем: если в подстроке есть X или Y (запрещённые буквы)\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        if ss.count('S') > 10 or ss.count('U') > 10 or ss.count('N') > 10:\n        # проверяем: если какая-то из букв S, U, N встречается больше 10 раз\n            break\n            # прерываем внутренний цикл - превышен лимит\n        # если все условия соблюдены - это допустимая подстрока\n        dl = len(ss)\n        # обновляем максимальную длину dl\n        # текущая подстрока длиннее всех предыдущих\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится искомая максимальная длина\n# самая длинная подстрока будет в последнем выводе на экран",
    "codeNoComments": "# f=open(r'D:\\24-7203.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='USNNSUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNXYXUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSNUSN'\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while i <= j <= len(s):\n        ss = s[i:j]\n        if 'X' in ss or 'Y' in ss:\n            break\n        if ss.count('S') > 10 or ss.count('U') > 10 or ss.count('N') > 10:\n            break\n        dl = len(ss)\n        print(f'i={i}, dl={dl}, строка:{ss}')\n        j += 1",
    "answer": "30",
    "image": "",
    "text": "Определите максимальное количество идущих подряд символов, среди которых каждая из букв S, U и N \r\nвстречается не более 10 раз, а буквы X и Y не встречаются совсем. \r\n",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "5152п",
    "codeWithComments": "# f=open(r'D:\\24-5152.txt')\n# открываем файл по указанному пути (закомментировано, так как нет доступа)\n\n# s=f.readline()\n# читаем первую строку из файла\n\n# print(len(s), s[:100])\n# выводим длину строки и первые 100 символов для проверки\n#=============================================================\ns='ABCABCABCABCABCABCABCABCABCAAAAAAAAAAABBBBBBBBBABCABCABCABCABCABCACCCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCABCABCABCABCABCABCABCABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\n# переменная для хранения длины текущей подстроки (изначально 0)\nfor i in range(len(s)):\n# перебираем все возможные начала подстрок (индекс i от 0 до конца строки)\n    j = i + dl + 1\n    # устанавливаем начальный индекс конца подстроки j\n    # начинаем с длины, превышающей текущую длину на 1\n    while j <= len(s):\n    # внутренний цикл: пока индекс конца j не выйдет за пределы строки\n        ss = s[i:j]\n        # извлекаем подстроку от i до j (символ с индексом j не включается)\n        if ('A' in ss) + ('B' in ss) + ('C' in ss) == 3:\n        # проверяем: если в подстроке есть все три буквы A, B и C одновременно\n            break\n            # прерываем внутренний цикл - дальше расширять подстроку бессмысленно\n        # если не все три буквы присутствуют - это допустимая подстрока\n        dl = len(ss)\n        # обновляем длину dl\n        print(i, dl, ss)\n        # выводим информацию о найденной подстроке (для отладки)\n        j += 1\n        # увеличиваем индекс конца подстроки, чтобы попробовать расширить её\n#=============================================================\n# после завершения всех циклов в переменной dl хранится длина последней найденной подстроки\n# но для подсчёта количества нужен отдельный счётчик",
    "codeNoComments": "# f=open(r'D:\\24-5152.txt')\n# s=f.readline()\n# print(len(s), s[:100])\n#=============================================================\ns='ABCABCABCABCABCABCABCABCABCAAAAAAAAAAABBBBBBBBBABCABCABCABCABCABCACCCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCABCABCABCABCABCABCABCABC'\n# создаём тестовую строку вручную, так как в этой среде нет доступа к файлу\n#=============================================================\ndl = 0\nfor i in range(len(s)):\n    j = i + dl + 1\n    while j <= len(s):\n        ss = s[i:j]\n        if ('A' in ss) + ('B' in ss) + ('C' in ss) == 3:\n            break\n        dl = len(ss)\n        print(i, dl, ss)\n        j += 1",
    "answer": "54",
    "image": "",
    "text": "Определите количество подстрок длиной не менее трех символов, которые не содержали бы одновременно все три буквы A, B и C.",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  }
]