[
  {
    "name": "№ 6283 (Сложный)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z, w):\n# Определяем логическую функцию fun от 4 переменных\n    return not( not(x <= (not w)) and z ) and not(w <= z) and (x <= (not z))\n    # Вычисляем значение сложного логического выражения:\n    # ¬ ( ¬( x → ¬w ) ∧ z ) ∧ ¬ ( w → z ) ∧ ( x → ¬z )\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a, b, c, d, e in product([0, 1], repeat=5):\n        # a,b,c,d,e - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=5) генерирует все возможные комбинации из 5 цифр 0 или 1\n        # Всего 2^5 = 32 комбинации\n        tab = [(1, 0, a, 0, 1), (1, 0, b, c, 0), (d, 1, e, 1, 0)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 5 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e - это неизвестные значения, которые мы перебираем\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (1, 0, a, 0, 1)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(1,0,a,0) получим:\n            #    [('x',1), ('y',0), ('z',a), ('w',0)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':1, 'y':0, 'z':a, 'w':0}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=1, y=0, z=a, w=0)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and rez == [1, 0, 0]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [1,0,0] - значения функции совпадают с последним столбцом таблицы\n            #    (по условию задачи в последнем столбце должны быть значения 1,0,0)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв  и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно\n            ",
    "codeNoComments": "from itertools import *\ndef fun(x, y, z, w):\n    return not( (x<= (not w)) and z ) and not(w <= z) and (x <= (not z))\nfor per in permutations('xyzw'):\n    for a, b, c, d, e in product([0, 1], repeat=5):\n        tab = [(1, 0, a, 0, 1), (1, 0, b, c, 0), (d, 1, e, 1, 0)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez == [1, 0, 0]:\n            print(*per, tab)\n            break",
    "answer": "8",
    "image": "",
    "text": "№ 6283 \r\nЛогическая функция F задаётся выражением \r\n¬ ( ¬ ( X → ¬ W ) ∧ Z ) ∧ ¬ ( W → Z ) ∧ ( X → ¬ Z ) \r\nНа рисунке приведён заполненный фрагмент таблицы истинности функции F, содержащий неповторяющиеся наборы аргументов \r\n? \t? \t? \t? \tF \r\n1 \t0 \t_ \t0 \t1 \r\n1 \t0 \t_ \t_ \t0\r\n_ \t1 \t_ \t1 \t0 \r\n\r\nОпределите, сколько существует различных способов расстановки переменных w, x, y, z подходящих для данной таблицы истинности? \r\n",
    "video": "https://rutube.ru/video/f1b87abef7a4bef410e4c6020fb34bdb/",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 2695 (Сложный)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z, w):\n# Определяем логическую функцию fun от 4 переменных\n    return (w or y) and (x <= (not z)) and not w\n    # Вычисляем значение логического выражения:\n    # (w ∨ y) ∧ ( x → ¬z ) ∧ ¬w\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        # a,b,c,d,e,f,g - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=7) генерирует все возможные комбинации из 7 цифр 0 или 1\n        # Всего 2^7 = 128 комбинаций\n        tab = [(a, 0, b, 0, 1), (1, c, d, e, 1), (1, 1, 0, 0, 1)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 5 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f,g - это неизвестные значения, которые мы перебираем\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (a, 0, b, 0, 1)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(a,0,b,0) получим:\n            #    [('x',a), ('y',0), ('z',b), ('w',0)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':a, 'y':0, 'z':b, 'w':0}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=a, y=0, z=b, w=0)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and all(fun(**dict(zip(per, c))) == c[-1] for c in tab):\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) Для каждой строки c в таблице tab значение функции fun\n            #    совпадает с последним элементом строки (значением F)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e,f,g\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно",
    "codeNoComments": "from itertools import *\ndef fun(x, y, z, w):\n    return (w or y) and (x <= (not z)) and not w\nfor per in permutations('xyzw'):\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        tab = [(a, 0, b, 0, 1), (1, c, d, e, 1), (1, 1, 0, 0, 1)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez == [1, 1, 1]:\n            print(*per, tab)\n            break",
    "answer": "4",
    "image": "",
    "text": "☐ № 2695  \t(Сложный) Сколько существует различных способов расстановки\nМиша заполнял таблицу истинности функции (w ∨ y) ∧ ( x → ¬z ) ∧ ¬w, но успел заполнить лишь фрагмент из трёх  её строк, даже не указав, какому столбцу таблицы соответствует каждая из переменных w,x,y,z\n?\t?\t?\t?\tF\n \t0\t \t0\t1\n1\t \t \t \t1\n1\t1\t0\t0\t1\nОпределите, сколько существует различных способов расстановки переменных w,x,y,z подходящих для данной таблицы истинности?4",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": true
  },
  {
    "name": "№ 332 дз (Сложный)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z, w):\n# Определяем логическую функцию fun от 4 переменных\n    return (x or y and (not z)) and (not w)\n    # Вычисляем значение логического выражения:\n    # (x ∨ y ∧ ¬z) ∧ ¬w\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a in product([0, 1], repeat=0):\n        # В этой таблице все значения известны, поэтому переменные для перебора не нужны (repeat=0)\n        tab = [(1, 0, 0, 0, 1), (0, 0, 1, 0, 1), (0, 1, 0, 1, 0)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 5 значений)\n        # Все значения в таблице известны\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (1, 0, 0, 0, 1)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(1,0,0,0) получим:\n            #    [('x',1), ('y',0), ('z',0), ('w',0)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':1, 'y':0, 'z':0, 'w':0}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=1, y=0, z=0, w=0)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and rez == [1, 1, 0]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [1,1,0] - значения функции совпадают с последним столбцом таблицы\n            #    (по условию задачи в последнем столбце должны быть значения 1,1,0)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций\n            # Так как решение уже найдено, дальше перебирать не нужно",
    "codeNoComments": "from itertools import *\ndef fun(x, y, z, w):\n    return (x or y and (not z)) and (not w)\nfor per in permutations('xyzw'):\n    for a in product([0, 1], repeat=0):\n        tab = [(1, 0, 0, 0, 1), (0, 0, 1, 0, 1), (0, 1, 0, 1, 0)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez == [1, 1, 0]:\n            print(*per, tab)\n            break",
    "answer": "4",
    "image": "",
    "text": "☐ № 332 дз \t(Сложный) Сколько существует различных способов расстановки\nДля приведенного фрагмента таблицы истинности выражения F=(x∨y∧¬z)∧¬w определите количество возможных последовательностей имен столбцов.\n?\t?\t?\t?\tF\n1\t0\t0\t0\t1\n0\t0\t1\t0\t1\n0\t1\t0\t1\t0\nВ ответе укажите только количество таких комбинаций.4",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 6989 дз (Средний)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyz\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z):\n# Определяем логическую функцию fun от 3 переменных\n    return x <= (y and z)\n    # Вычисляем значение логического выражения:\n    # x → y ∧ z\n# ==============================================\nfor per in permutations('xyz'):\n    # per - очередной вариант переставленных букв, например ('x','y','z') или ('x','z','y')\n    # Всего 3! = 6 возможных перестановок\n    for a in product([0, 1], repeat=0):\n        # В этой таблице все значения известны, поэтому переменные для перебора не нужны (repeat=0)\n        tab = [(0, 1, 0, 0), (1, 1, 0, 0)]\n        # Создаем таблицу из 2 строк (каждая строка - кортеж из 4 значений)\n        # Все значения в таблице известны\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (0, 1, 0, 0)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyz) и их значения (0/1):\n            #    например, при per=('x','y','z') и t=(0,1,0) получим:\n            #    [('x',0), ('y',1), ('z',0)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':0, 'y':1, 'z':0}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=0, y=1, z=0)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 2 and rez == [0, 0]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 2 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [0,0] - значения функции совпадают с последним столбцом таблицы\n            #    (по условию задачи в последнем столбце должны быть значения 0,0)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z\n            break\n            # Выходим из внутреннего цикла перебора комбинаций\n            # Так как решение уже найдено, дальше перебирать не нужно",
    "codeNoComments": "from itertools import *\ndef fun(x, y, z):\n    return x <= (y and z)\nfor per in permutations('xyz'):\n    for a in product([0, 1], repeat=0):\n        tab = [(0, 1, 0, 0), (1, 1, 0, 0)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 2 and rez == [0, 0]:\n            print(*per, tab)\n            break",
    "answer": "2",
    "image": "",
    "text": "☐ № 6989  дз\t(Средний)  Сколько существует различных способов расстановки\nЛогическая функция F задаётся выражением x→y∧z. На рисунке приведён фрагмент таблицы истинности функции F, содержащий неповторяющиеся наборы аргументов.\n?\t?\t?\tF\n0\t1\t0\t0\n1\t1\t0\t0\nОпределите, сколько существует различных способов расстановки переменных 2",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 12671 дз (Средний)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z, w):\n# Определяем логическую функцию fun от 4 переменных\n    return not (x == (w and (not z))) and (y == (x and not w))\n    # Вычисляем значение логического выражения:\n    # ¬(x ≡ w ∧ ¬z) ∧ (y ≡ x ∧ ¬w)\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        # a,b,c,d,e,f,g - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=7) генерирует все возможные комбинации из 7 цифр 0 или 1\n        # Всего 2^7 = 128 комбинаций\n        tab = [(a, b, 0, c, 1), (d, 0, e, 0, 1), (0, f, 1, 0, 1)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 5 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f,g - это неизвестные значения, которые мы перебираем\n        # Последний столбец - значение функции F\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (a, b, 0, c, 1)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(a,b,0,c) получим:\n            #    [('x',a), ('y',b), ('z',0), ('w',c)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':a, 'y':b, 'z':0, 'w':c}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=a, y=b, z=0, w=c)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and rez == [1, 1, 1]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [1,1,1] - значения функции совпадают с последним столбцом таблицы\n            #    (по условию задачи в последнем столбце должны быть значения 1,1,1)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e,f,g\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно",
    "codeNoComments": "from itertools import *\ndef fun(x, y, z, w):\n    return not (x == (w and (not z))) and (y == (x and not w))\nfor per in permutations('xyzw'):\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        tab = [(a, b, 0, c, 1), (d, 0, e, 0, 1), (0, f, 1, 0, 1)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez == [1, 1, 1]:\n            print(*per, tab)\n            break",
    "answer": "Wxyz",
    "image": "",
    "text": "☐ № 12671 дз\t(Средний)  БАЗОВЫЙ КОД – ПОРЯДОК ДЕЙСТВИЙ!!!\nЛогическая функция F задаётся выражением ¬(x≡w∧¬z)∧(y≡x∧¬w). На рисунке приведён частично заполненный фрагмент таблицы истинности функции F, содержащий неповторяющиеся строки. Определите, какому столбцу таблицы истинности соответствует каждая из переменных w,x,y,z.\n?\t?\t?\t?\tF\n \t \t0\t \t1\n \t0\t \t0\t1\n0\t \t1\t0\t1\nWxyz",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 13077 (Средний)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun1(x, y, z, w):\n# Определяем первую функцию fun1 от 4 переменных\n    return (w == x) and (y <= z)\n    # Вычисляем значение логического выражения:\n    # (w ≡ x) ∧ (y → z)\n# ==============================================\ndef fun2(x, y, z, w):\n# Определяем вторую функцию fun2 от 4 переменных\n    return (w <= x) <= (y == z)\n    # Вычисляем значение логического выражения:\n    # (w → x) → (y ≡ z)\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        # a,b,c,d,e,f,g - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=7) генерирует все возможные комбинации из 7 цифр 0 или 1\n        # Всего 2^7 = 128 комбинаций\n        tab = [(1, a, 1, 1, 1, 0), (b, 1, 0, 0, 1, c), (d, 0, 0, e, 0, 0)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 6 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f,g - это неизвестные значения, которые мы перебираем\n        # Последние два столбца - значения F1 и F2\n        rez1 = []\n        rez2 = []\n        # Создаем пустые списки для хранения результатов вычисления функций\n        for t in tab:\n            # t - очередная строка таблицы, например (1, a, 1, 1, 1, 0)\n            rez1.append(fun1(**dict(zip(per, t))))\n            rez2.append(fun2(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(1,a,1,1) получим:\n            #    [('x',1), ('y',a), ('z',1), ('w',1)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':1, 'y':a, 'z':1, 'w':1}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun1(x=1, y=a, z=1, w=1)\n            # 4. Результат вычисления функции добавляем в список rez1\n        if len(set(tab)) == 3 and rez1 == [1, 1, 0] and rez2 == [0, 1, 0]:\n            # Проверяем условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez1 == [1,1,0] - значения первой функции совпадают с предпоследним столбцом\n            # 3) rez2 == [0,1,0] - значения второй функции совпадают с последним столбцом\n            print(*per, tab)\n            # Если условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций\n            # Так как решение уже найдено, дальше перебирать не нужно",
    "codeNoComments": "from itertools import *\ndef fun1(x, y, z, w):\n    return (w == x) and (y <= z)\ndef fun2(x, y, z, w):\n    return (w <= x) <= (y == z)\nfor per in permutations('xyzw'):\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        tab = [(1, a, 1, 1, 1, 0), (b, 1, 0, 0, 1, c), (d, 0, 0, e, 0, 0)]\n        rez1 = []\n        rez2 = []\n        for t in tab:\n            rez1.append(fun1(**dict(zip(per, t))))\n            rez2.append(fun2(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez1 == [1, 1, 0] and rez2 == [0, 1, 0]:\n            print(*per, tab)\n            break",
    "answer": "Zywx",
    "image": "",
    "text": "☐ № 13077 \t(Средний)  2 ФУНКЦИИ – ЗНАЧЕНИЯ не СОВПАДАЮТ\nДве логические функции заданы выражениями:\nF1=(w≡x)∧(y→z)\nF2=(w→x)→(y≡z)\nДан частично заполненный фрагмент, содержащий неповторяющиеся строки таблицы истинности обеих функций.\n?\t?\t?\t?\tF1\tF2\n1\t \t1\t1\t1\t0\n \t1\t0\t0\t1\t \n \t0\t0\t \t0\t0\nОпределите, какому столбцу таблицы истинности соответствует каждая из переменных w,x,y,z.\nВ ответе напишите буквы w,x,y,z в том порядке, в котором идут соответствующие им столбцы (сначала буква, соответствующая первому столбцу; затем буква, соответствующая второму столбцу, и т. д.). Буквы в ответе пишите подряд, никаких разделителей между буквами ставить не нужно. Zywx",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 9357 дз (Средний)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzw\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun1(x, y, z, w):\n# Определяем первую функцию fun1 от 4 переменных\n    return (x <= y) or (not w == z)\n    # Вычисляем значение логического выражения:\n    # (x → y) ∨ (¬w ≡ z)\n# ==============================================\ndef fun2(x, y, z, w):\n# Определяем вторую функцию fun2 от 4 переменных\n    return (x <= y) == (w and not z)\n    # Вычисляем значение логического выражения:\n    # (x → y) ≡ (w ∧ ¬z)\n# ==============================================\nfor per in permutations('xyzw'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w') или ('x','w','z','y')\n    # Всего 4! = 24 возможных перестановки \n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        # a,b,c,d,e,f,g - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=7) генерирует все возможные комбинации из 7 цифр 0 или 1\n        # Всего 2^7 = 128 комбинаций\n        tab = [(a, b, c, 0), (d, e, 0, 0), (f, 0, 0, 0)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 4 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f,g - это неизвестные значения, которые мы перебираем\n        # В таблице только столбцы переменных, значения функций не указаны\n        rez1 = []\n        rez2 = []\n        # Создаем пустые списки для хранения результатов вычисления функций\n        for t in tab:\n            # t - очередная строка таблицы, например (a, b, c, 0)\n            rez1.append(fun1(**dict(zip(per, t))))\n            rez2.append(fun2(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzw) и их значения (0/1):\n            #    например, при per=('x','y','z','w') и t=(a,b,c,0) получим:\n            #    [('x',a), ('y',b), ('z',c), ('w',0)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':a, 'y':b, 'z':c, 'w':0}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun1(x=a, y=b, z=c, w=0)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and rez1 == rez2:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez1 == rez2 - значения функций для наборов из фрагмента равны\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку букв и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: x y z w\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e,f,g\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно",
    "codeNoComments": "from itertools import *\ndef fun1(x, y, z, w):\n    return (x <= y) or (not w == z)\ndef fun2(x, y, z, w):\n    return (x <= y) == (w and not z)\nfor per in permutations('xyzw'):\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        tab = [(a, b, c, 0), (d, e, 0, 0), (f, 0, 0, 0)]\n        rez1 = []\n        rez2 = []\n        for t in tab:\n            rez1.append(fun1(**dict(zip(per, t))))\n            rez2.append(fun2(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez1 == rez2:\n            print(*per, tab)\n            break",
    "answer": "Wyxz",
    "image": "",
    "text": "☐ № 9357 дз (Средний)   2 ФУНКЦИИ – ЗНАЧЕНИЯ СОВПАДАЮТ\nМиша заполнял таблицу истинности для двух функций \n(x→y)∨(¬w≡z)     и      (x→y)≡(w∧¬z),     \nно успел заполнить лишь фрагмент из трёх различных её строк, даже не указав, какому столбцу таблицы соответствует каждая из переменных w,x,y,z. \n?\t?\t?\t?\n_\t_\t_\t0\n_\t_\t0\t0\n_\t0\t0\t0\nОпределите, какому столбцу таблицы истинности функции F соответствует каждая из переменных x,y,z,w, если известно, что значения функций для наборов из фрагмента равны. \nWyxz",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 6837 (Средний)",
    "codeWithComments": "from itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв xyzwq\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(x, y, z, w, q):\n# Определяем логическую функцию fun от 5 переменных\n    return (x or not y or (not z) or w or (not q)) and \\\n           ((not x) or (not y) or z or w or q) and (x or (not y) or (not z) or (not w) or q)\n    # Вычисляем значение сложного логического выражения:\n    # (x ∨ ¬y ∨ ¬z ∨ w ∨ ¬q) ∧ (¬x ∨ ¬y ∨ z ∨ w ∨ q) ∧ (x ∨ ¬y ∨ ¬z ∨ ¬w ∨ q)\n# ==============================================\nfl = True\n# Флаг для остановки перебора после нахождения решения\nfor per in permutations('xyzwq'):\n    # per - очередной вариант переставленных букв, например ('x','y','z','w','q') или ('x','w','z','y','q')\n    # Всего 5! = 120 возможных перестановок\n    if fl == False: break\n    # Если решение уже найдено, прекращаем перебор перестановок\n    for a, b, c, d, e, f in product([0, 1], repeat=6):\n        # a,b,c,d,e,f - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=6) генерирует все возможные комбинации из 6 цифр 0 или 1\n        # Всего 2^6 = 64 комбинации\n        tab = [(0, 1, 1, 0, a, 1), (0, 1, 1, 1, 0, b), (0, 1, c, d, 1, 0), (0, 0, 0, 1, 0, e)]\n        # Создаем таблицу из 4 строк (каждая строка - кортеж из 6 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f - это неизвестные значения, которые мы перебираем\n        # Последний столбец - значение функции F\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (0, 1, 1, 0, a, 1)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет буквы (xyzwq) и их значения (0/1):\n            #    например, при per=('x','y','z','w','q') и t=(0,1,1,0,a) получим:\n            #    [('x',0), ('y',1), ('z',1), ('w',0), ('q',a)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'x':0, 'y':1, 'z':1, 'w':0, 'q':a}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(x=0, y=1, z=1, w=0, q=a)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 4 and rez == [1, b, 0, e]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 4 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [1, b, 0, e] - значения функции совпадают с последним столбцом таблицы\n            #    В последнем столбце значения: 1 (из первой строки), b (из второй строки),\n            #    0 (из третьей строки), e (из четвертой строки)\n            print(a, b, c, d, e)\n            # Выводим искомые значения a,b,c,d,e\n            fl = False\n            # Устанавливаем флаг для остановки перебора\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e,f\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно",
    "codeNoComments": "from itertools import *\ndef fun(x,y,z,w,q): return (x or  not y or  (not z) or w or  (not q)) and\\\n    ( (not x) or ( not y) or z or w or q) and (x or  (not y) or  (not z) or  (not w) or q)\nfl=True\nfor per in permutations('xyzwq'):\n    if fl==False: break\n    for a, b, c, d, e, f in product([0, 1], repeat=6):\n        tab = [(0,1,1,0,a,1),  (0,1,1,1,0,b),  (0,1,c,d,1,0),  (0,0,0,1,0,e)]\n        rez=[]\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\\\n        if len(set(tab))==4 and rez==[1,b,0,e]:\n            # print(*per,tab)\n            print(a,b,c,d,e)\n            fl=False\n            break\n",
    "answer": "00101",
    "image": "",
    "text": "☐ № 6837 \t(Средний)  ** 5 переменных – неизвестны числа в таблице\nДана логическая функция пяти логических переменных:\nf(x1,x2,x3,x4,x5)=(x1∨¬x2∨¬x3∨x4∨¬x5)∧(¬x1∨¬x2∨x3∨x4∨x5)∧(x1∨¬x2∨¬x3∨¬x4∨x5)\nи фрагмент таблицы истинности этой функции с неизвестными значениями некоторых ячеек.\nx1\tx2\tx3\tx4\tx5\tf\n0\t1\t1\t0\ta\t1\n0\t1\t1\t1\t0\tb\n0\t1\tc\td\t1\t0\n0\t0\t0\t1\t0\te\nУкажите в ответе значения неизвестных величин a,b,c,d,e подряд без пробелов и запятых.\n00101",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  },
  {
    "name": "№ 5424 (Сложный)",
    "codeWithComments": "# ==============================================\n\nfrom itertools import *\n# Импортируем функции для работы с функциями:\n# permutations - для перебора всех перестановок букв p1,p2,p3,p4\n# product - для перебора всех возможных комбинаций 0 и 1\n# ==============================================\ndef fun(p1, p2, p3, p4):\n# Определяем логическую функцию fun от 4 переменных\n    return (p3 <= p1) <= (p4 or not p2)\n    # Вычисляем значение логического выражения:\n    # (p3 → p1) → (p4 ∨ ¬p2)\n# ==============================================\nfor per in permutations(['p1', 'p2', 'p3', 'p4']):\n    # per - очередной вариант переставленных переменных, например ('p1','p2','p3','p4') или ('p1','p3','p2','p4')\n    # Всего 4! = 24 возможных перестановки\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        # a,b,c,d,e,f,g - это неизвестные значения в таблице истинности (обозначены как ?)\n        # product([0,1], repeat=7) генерирует все возможные комбинации из 7 цифр 0 или 1\n        # Всего 2^7 = 128 комбинаций\n        tab = [(0, 0, a, 1, 0), (0, 1, b, 1, 0), (1, 1, c, d, 0)]\n        # Создаем таблицу из 3 строк (каждая строка - кортеж из 5 значений)\n        # В каждой строке:\n        # - цифры 0 и 1 - это известные значения из условия\n        # - буквы a,b,c,d,e,f,g - это неизвестные значения, которые мы перебираем\n        # Последний столбец - значение функции F\n        rez = []\n        # Создаем пустой список для хранения результатов вычисления функции\n        for t in tab:\n            # t - очередная строка таблицы, например (0, 0, a, 1, 0)\n            rez.append(fun(**dict(zip(per, t))))\n            # Разбираем по шагам:\n            # 1. zip(per, t) - соединяет имена переменных (p1,p2,p3,p4) и их значения (0/1):\n            #    например, при per=('p1','p2','p3','p4') и t=(0,0,a,1) получим:\n            #    [('p1',0), ('p2',0), ('p3',a), ('p4',1)]\n            # 2. dict(...) - превращает список кортежей в словарь: {'p1':0, 'p2':0, 'p3':a, 'p4':1}\n            # 3. **dict - распаковывает словарь в аргументы функции: fun(p1=0, p2=0, p3=a, p4=1)\n            # 4. Результат вычисления функции добавляем в список rez\n        if len(set(tab)) == 3 and rez == [0, 0, 0]:\n            # Проверяем два условия:\n            # 1) len(set(tab)) == 3 - все строки таблицы разные (нет повторяющихся)\n            #    set(tab) превращает список строк в множество, убирая дубликаты\n            # 2) rez == [0,0,0] - значения функции совпадают с последним столбцом таблицы\n            #    (по условию задачи в последнем столбце должны быть значения 0,0,0)\n            print(*per, tab)\n            # Если оба условия выполнены - нашли решение\n            # Выводим: порядок перестановку переменных и саму таблицу истинности для дальнейшей проверки\n            # *per распаковывает перестановку, например выведет: p1 p2 p3 p4\n            break\n            # Выходим из внутреннего цикла перебора комбинаций a,b,c,d,e,f,g\n            # Так как решение уже найдено, дальше перебирать комбинации не нужно",
    "codeNoComments": "from itertools import *\ndef fun(p1, p2, p3, p4):\n    return (p3 <= p1) <= (p4 or not p2)\nfor per in permutations(['p1', 'p2', 'p3', 'p4']):\n    for a, b, c, d, e, f, g in product([0, 1], repeat=7):\n        tab = [(0, 0, a, 1, 0), (0, 1, b, 1, 0), (1, 1, c, d, 0)]\n        rez = []\n        for t in tab:\n            rez.append(fun(**dict(zip(per, t))))\n        if len(set(tab)) == 3 and rez == [0, 0, 0]:\n            print(*per, tab)\n            break",
    "answer": "ywxz",
    "image": "",
    "text": "☐ № 5424  \t(Сложный) ** БАЗОВЫЙ КОД в таблице порядок известен, а в функции нет\nЛогическая функция F задаётся выражением (p3→p1)→(p4∨¬p2). На рисунке приведён частично заполненный фрагмент таблицы истинности  функции F, содержащий неповторяющиеся строки. Определите, какой столбец в таблице каждой переменной в выражении.\nx\ty\tz\tw\tF\n0\t0\t \t1\t0\n0\t1\t \t1\t0\n1\t1\t \t \t0\nВ ответе напишите буквы x,y,z,w  в том порядке, который соответствует переменным p1,p2,p3 и p4 в выражении. Буквы в ответе пишите подряд, никаких разделителей между буквами ставить не нужно.ywxz",
    "video": "",
    "fileUrl": "",
    "solved": false,
    "favorite": false
  }
]